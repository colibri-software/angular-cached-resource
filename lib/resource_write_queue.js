// Generated by CoffeeScript 1.7.1
var CACHE_RETRY_TIMEOUT, Cache, ResourceCacheEntry, ResourceWriteQueue;

CACHE_RETRY_TIMEOUT = 60000;

ResourceCacheEntry = require('./resource_cache_entry');

Cache = require('./cache');

ResourceWriteQueue = (function() {
  function ResourceWriteQueue(CachedResource, $timeout) {
    this.CachedResource = CachedResource;
    this.$timeout = $timeout;
    this.key = "" + this.CachedResource.$key + "/write";
    this.queue = Cache.getItem(this.key, []);
  }

  ResourceWriteQueue.prototype.enqueue = function(params, resourceData, action, deferred) {
    var resourceParams, write, _ref, _ref1;
    resourceParams = angular.isArray(resourceData) ? resourceData.map(function(resource) {
      return resource.$params();
    }) : resourceData.$params();
    write = this.findWrite({
      params: params,
      action: action
    });
    if (write == null) {
      this.queue.push({
        params: params,
        resourceParams: resourceParams,
        action: action,
        deferred: deferred
      });
      return this._update();
    } else {
      if ((_ref = write.deferred) != null) {
        _ref.promise.then(function(response) {
          return deferred.resolve(response);
        });
      }
      return (_ref1 = write.deferred) != null ? _ref1.promise["catch"](function(error) {
        return deferred.reject(error);
      }) : void 0;
    }
  };

  ResourceWriteQueue.prototype.findWrite = function(_arg) {
    var action, params, write, _i, _len, _ref;
    action = _arg.action, params = _arg.params;
    _ref = this.queue;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      write = _ref[_i];
      if (action === write.action && angular.equals(params, write.params)) {
        return write;
      }
    }
  };

  ResourceWriteQueue.prototype.removeWrite = function(_arg) {
    var action, entry, newQueue, params, _i, _len, _ref;
    action = _arg.action, params = _arg.params;
    newQueue = [];
    _ref = this.queue;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entry = _ref[_i];
      if (!(action === entry.action && angular.equals(params, entry.params))) {
        newQueue.push(entry);
      }
    }
    this.queue = newQueue;
    if (this.queue.length === 0 && this.timeoutPromise) {
      this.$timeout.cancel(this.timeoutPromise);
      delete this.timeoutPromise;
    }
    return this._update();
  };

  ResourceWriteQueue.prototype.flush = function() {
    var write, _i, _len, _ref;
    this._setFlushTimeout();
    _ref = this.queue;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      write = _ref[_i];
      this._processWrite(write);
    }
    if (!this.CachedResource.$retryFailedRequests) {
      return this.queue = [];
    }
  };

  ResourceWriteQueue.prototype.processResource = function(params, done) {
    var notDone, write, _i, _len, _ref, _results;
    notDone = true;
    _ref = this._writesForResource(params);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      write = _ref[_i];
      _results.push(this._processWrite(write, (function(_this) {
        return function() {
          if (notDone && _this._writesForResource(params).length === 0) {
            notDone = false;
            return done();
          }
        };
      })(this)));
    }
    return _results;
  };

  ResourceWriteQueue.prototype._writesForResource = function(params) {
    var write, _i, _len, _ref, _results;
    _ref = this.queue;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      write = _ref[_i];
      if (angular.equals(params, write.params)) {
        _results.push(write);
      }
    }
    return _results;
  };

  ResourceWriteQueue.prototype._processWrite = function(write, done) {
    var cacheEntries, onFailure, onSuccess, writeData;
    if (angular.isArray(write.resourceParams)) {
      cacheEntries = write.resourceParams.map((function(_this) {
        return function(resourceParams) {
          return new ResourceCacheEntry(_this.CachedResource.$key, resourceParams).load();
        };
      })(this));
      writeData = cacheEntries.map(function(cacheEntry) {
        return cacheEntry.value;
      });
    } else {
      cacheEntries = [new ResourceCacheEntry(this.CachedResource.$key, write.resourceParams).load()];
      writeData = cacheEntries[0].value;
    }
    onSuccess = (function(_this) {
      return function(value) {
        var cacheEntry, _i, _len, _ref;
        _this.removeWrite(write);
        for (_i = 0, _len = cacheEntries.length; _i < _len; _i++) {
          cacheEntry = cacheEntries[_i];
          cacheEntry.setClean();
        }
        if ((_ref = write.deferred) != null) {
          _ref.resolve(value);
        }
        if (angular.isFunction(done)) {
          return done();
        }
      };
    })(this);
    onFailure = (function(_this) {
      return function(error) {
        var _ref;
        return (_ref = write.deferred) != null ? _ref.reject(error) : void 0;
      };
    })(this);
    return this.CachedResource.$resource[write.action](write.params, writeData, onSuccess, onFailure);
  };

  ResourceWriteQueue.prototype._setFlushTimeout = function() {
    if (this.queue.length > 0 && !this.timeoutPromise) {
      this.timeoutPromise = this.$timeout(angular.bind(this, this.flush), CACHE_RETRY_TIMEOUT);
      return this.timeoutPromise.then((function(_this) {
        return function() {
          delete _this.timeoutPromise;
          return _this._setFlushTimeout();
        };
      })(this));
    }
  };

  ResourceWriteQueue.prototype._update = function() {
    var savableQueue;
    savableQueue = this.queue.map(function(write) {
      return {
        params: write.params,
        resourceParams: write.resourceParams,
        action: write.action
      };
    });
    return Cache.setItem(this.key, savableQueue);
  };

  return ResourceWriteQueue;

})();

module.exports = ResourceWriteQueue;
